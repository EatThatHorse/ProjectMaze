
#ifndef c_hotel
#define c_hotel

    #include "c_room"

    #include <cstdlib>      // [srand]
    #include <iostream>
    using namespace std;

    enum roomDirection { UP, LEFT, RIGHT };

    class hotel {
    public:
        /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ///     KONSTRUKTORY
        /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


        /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ///     DEKONSTRUKTORY
        /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ///    ZMIENNE
        /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    public:         // [Kacu]: Dawaj osobna etykiete do kazdego typu elementow klasy. To pomaga.


        /// [Kacu]:
        room* lastRoom;     // Umozliwi dodawanie pokoi.
        room* currentRoom; // Na starcie wskazuje na zeroRoom. Umozliwi poruszanie sie gracza miedzy pokojami.
        int nr;

        /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ///     METODY
        /// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    public:
        //hotel MakeHotel(room* = NULL, room* = NULL, room* = NULL, room* = NULL, room* = NULL,room* = NULL);

        void Ok_Path(int , int);
        void Blind_Path(int , int);

        int RandomSet(int,int);

        void  ShowHotel(room*);
        void  ShowEAST(room* );
        void  ShowWEST(room* );
        void  ShowHotel2(room*,int);
        void AddFloor();
        void AddFloor2() ;

        void AddRoom (roomDirection , bool );


    /*
        void PrintHotel();
        hotel MakeHotel(room* = NULL, room* = NULL, room* = NULL, room* = NULL, room* = NULL,room* = NULL);
        hotel SetRoom(room tmpRoom);
    */
    private:



        /// [Kacu]  Hmmmm
        /**--------------------------------------------------------------------------------------------------
        [Komentuje Jak szalony, Ale to nie oznacza ze kod jest do zablokowania, zapomnienia]
        hotel MakeHotel (room* pok1, room* pok2, room* pok3, room* pok4, room* pok5,room* pok6) {
            hotel SetRoom(room);
            void PrintHotel(hotel);
            hotel MakeHotel(room* = NULL,room* = NULL,room* = NULL,room* = NULL,room* = NULL,room* = NULL);
        }

        hotel MakeHotel(room* pok1, room* pok2, room* pok3, room* pok4, room* pok5,room* pok6){
            hotel h;
            h.r1 = pok1;
            h.r2 = pok2;
            h.r3 = pok3;
            h.r4 = pok4;
            h.r5 = pok5;
            h.r6 = pok6;
            return h;

        }
        --------------------------------------------------------------------------------------------------*/



        /**   [Kacu]
            - Mamy juz jeden obiekt typu hotel. Powstal on w mainie().
            - Teraz to co chcemy zrobic to dodawac do niego pokoje.
            - Proponuje napisanie 3 metod.
              Albo
              jednej wiekszej a nastepnie podzielic ja na mniejsze.
              (nie wszystko da sie od razu zaplanowac)
        */
    //    void AddFloor (hotel& HeadHotel);
            /** - Metoda zajmuje sie dodaniem calego pietra na raz.
                  Rozpoczynamy gre → Dodajemy poczotkowe pietro →
                  gracz je przechodzi → dodajemy kolejne pietro →
                  gracz je przechodzi → dodajemy kolejne pietro → ...

                - W argumencie przyjmuje referencje do glownego hotelu utworzonego w mainie().
                  Dzieki temu wszelkie zmiany ktore dokonamy na HeadHotel dokonaja sie na tym glownym, mainowym hotelu.
                - Zwracamy void, bo dzialajac na referencji nie musimy zwracac hotelu.
                  W miare pisania mozesz zmienic void na bool lub int, w celu kontroli bledow.

                - Metoda musi wiedziec jaki rodzaj pietra ma dodac.
                  Wiec najpierw odpalamy inna metode ktora nam wylosuje set.
                  [RandomSet]
                - Dalej pewnie switch case do kazdego scenariusza, setu.
                    [Przykład dla setu 0]
                    - zaczynamy od [HeadHotel.lastRoom] poniewaz to adres ostatniego dodanego pokoju.
                    - tworzymy nowyPokoj. dodajemy go do northWskaznika pokoju lastRoom.
                        HeadHotel.lastRoom->north = &nowyPokoj;  // znak & zwraca adres nowyPokoj.
                    - To najprostszy przyklad wiec konczymy. Jeszcze tylko zUpdatowac lastRoom by wskazywal na
                      nowy, najwyzszy pokoj. Czyli:
                        HeadHotel.lastRoom = &nowyPokoj;  // Wczesniej modyfikowalismy pokoj na ktory wskazywal lastRoom.
                                                          // Teraz modyfikujemy lastRoom ktory jest zmienna z klasy hotel.

                    [Przykład dla setu 5]       ─┬┘       // [Jeden PRAWO i jeden UP] + Jeden pokoj w LEWO (slepy zaulek).
                    - Ponownie, zaczynamy od [HeadHotel.lastRoom]. Caly poczatek tak samo.
                    - tworzymy nowyPokoj. dodajemy go do northWskaznika pokoju lastRoom.
                        HeadHotel.lastRoom->north = &nowyPokoj;
                    - Updatujemy lastRoom by wskazywal na nowy pokoj. [┬]
                        HeadHotel.lastRoom = &nowyPokoj;
                    - Teraz zabral bym sie za slepy zaulek w lewo. Robie nowy pokoj i podpinam go do lastRoom.
                        HeadHotel.lastRoom->west = &nowyPokoj;  // Zobacz ze robie to do wskaznika WEST!
                    - Jak mam juz podpiecie lastRoom [┬] do nowego pokoju(slepego zaulka) [─].
                      To musze podpiac z drugiej strony. Czyli Nowy pokoj [─] do lastRoom [┬].
                        HeadHotel.lastRoom->west->east = HeadHotel.lastRoom;    // bez &, bo lastRoom jest wskaznikiem.
                                              |     └─ wskaznik east pokoju slepy zaulek [─]. Bo:
                                              └─────── west juz wskazuje na pokoj slepy zaulek [─].
                                                       Dostalem sie do czego chcialem za pomocom wskaznikow.
                    - Nastepnie, jak mam juz zaulek z glowy, Biere sie za glowna droge w PRAWO.
                      wskaznik HeadHotel.lastRoom nadal wskazuje na [┬]. wiec lece od razu w prawo.
                        HeadHotel.lastRoom->east = &nowyPokoj;
                        // Pamietam by podpiac w drugo strone. Czyli to [┘] z tym [┬], wiec:
                        HeadHotel.lastRoom->east->west = HeadHotel.lastRoom;
                        // zmianiam ustawienie wskaznika lastRoom na pokoj z prawej.
                        HeadHotel.lastRoom = HeadHotel.lastRoom->east       // Teraz jestesmy tu [┘].
                        // wiec pozostaje nam jeden UP. Ale go nie dodajemy teraz! Bo bysmy w jednym casie skoczyli o dwa pietra.
                        // zrobilismy to:  [─┬┘] Czyli zaczynajac raz juz poszlismy do gory robiac to [┬].

                - Moja propozycja na Sety:
                    0          |         Ostatecznie to zawsze jest jeden do gory. Nie mniej, nie wiecej. Na raz dodajemy maks jedno pietro.
                    1          ┌┘        Jeden w PRAWO i jeden do gory.
                   -1         └┐         Jeden w LEWO i jeden do gory.
                    2          ┌─┘       Dwa w PRAWO i jeden do gory.
                   -2        └─┐         Dwa w LEWO i jeden do gory.
                    3          ┌──┘      Trzy w PRAWO i jeden ...
                   -3       └──┐         Trzy w LEWO i jeden ...

                    I mysle by dalej w prawo/lewo nie isc, dac tylko slepe zaulki.
                    Jak bedzie ostatecznie. Zobaczymy w miare rozwoju projektu.

                    4         ─┤         [Jeden UP] + Jeden pokoj w LEWO (slepy zaulek).
                   -4          ├─        [Jeden UP] + Jeden pokoj w PRAWO (slepy zaulek).
                    5         ─┬┘        [Jeden PRAWO i jeden UP] + Jeden pokoj w LEWO (slepy zaulek).
                   -5         └┬─        [Jeden LEWO i jeden UP] + Jeden pokoj w PRAWO (slepy zaulek).
                    6         ─┬─┘       [Dwa PRAWO i jeden UP] + Jeden pokoj w LEWO (slepy zaulek).
                   -6        └─┬─        [Dwa LEWO i jeden UP] + Jeden pokoj w PRAWO (slepy zaulek).
                    7         ─┬──┘      [Trzy PRAWO i jeden UP] + Jeden pokoj w LEWO (slepy zaulek).
                   -7       └──┬─        [Trzy LEWO i jeden UP] + Jeden pokoj w PRAWO (slepy zaulek).

                   Tak Mozna bez konca, tak dlugo jak bedziesz mial checi. Tylko nie zaczynaj nowych gdy stare nie dzialaja!

                    8        ──┤         [Jeden UP] + Dwa LEWO (slepy zaulek).
                   -8          ├──       [Jeden UP] + Dwa PRAWO (slepy zaulek).
                    9        ──┬┘        [Jeden PRAWO i jeden UP] + Dwa LEWO (slepy zaulek).
                   -9         └┬──       [Jeden LEWO i jeden UP]  + Dwa PRAWO (slepy zaulek).
                   10        ──┬─┘       [Dwa PRAWO i jeden UP]   + Dwa LEWO (slepy zaulek).
                  -10        └─┬──       [Dwa LEWO i jeden UP]    + Dwa PRAWO (slepy zaulek).
                   11        ──┬──┘      [Trzy PRAWO i jeden UP]  + Dwa LEWO (slepy zaulek).
                  -11       └──┬──       [Trzy LEWO i jeden UP]   + Dwa PRAWO (slepy zaulek).

                  Wszystko to powyzej jest jedynie moja propozycja. Jak znajdziesz wygodniejszy dla siebie
                  rozklad scenariuszy, uzywaj swojego. Liczby nie musza tez byc ujemne, jak wolisz by wszystkie byly dodatnie.
            */

    //    int RandomSet(int Rmin, int Rmax);
            /** - Metoda losuje liczbe z przedzialu [-6 ; 6] ← Na razie starczy.
                  Bedziesz mial ochote zrobisz [-12 ; 12] albo [-36 ; 36]...
                - Zwraca wynik.
                - Argumenty to zakres losowanych liczb. Przyda sie ci do testowania scenariuszy.
        }    */

    };

#endif // c_hotel
